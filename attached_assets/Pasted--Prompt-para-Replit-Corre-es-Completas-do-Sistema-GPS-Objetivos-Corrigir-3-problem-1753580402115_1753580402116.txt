# ğŸ”§ Prompt para Replit: CorreÃ§Ãµes Completas do Sistema GPS

## ğŸ“‹ Objetivos
Corrigir **3 problemas crÃ­ticos** no sistema de GPS tracker:

1. **Timestamps incorretos** - Sistema usando data do dispositivo em vez do servidor
2. **Heartbeats como novas conexÃµes** - `+ACK:GTHBD` estÃ¡ sendo contado como nova conexÃ£o
3. **GTSTT nÃ£o processado** - Mensagens de mudanÃ§a de estado nÃ£o estÃ£o sendo capturadas

## ğŸš¨ Problemas Identificados

### âŒ Problema 1: Timestamps
- A data do sistema estÃ¡ sendo a mesma do dispositivo
- Isso causa inconsistÃªncia temporal nos dados
- Logs e banco de dados ficam com timestamps incorretos

### âŒ Problema 2: Heartbeats duplicando conexÃµes  
- Cada mensagem `+ACK:GTHBD` estÃ¡ sendo contada como nova conexÃ£o
- O mesmo dispositivo aparece mÃºltiplas vezes como "conectado"
- EstatÃ­sticas de conexÃµes ficam incorretas

### âŒ Problema 3: GTSTT nÃ£o capturado
- Mensagens `+RESP:GTSTT` nÃ£o estÃ£o sendo processadas
- MudanÃ§as de estado do dispositivo (ex: "41" = Sensor Rest) nÃ£o sÃ£o salvas
- Perda de informaÃ§Ãµes importantes sobre status do veÃ­culo

## âœ… SoluÃ§Ãµes Requeridas

### ğŸ”§ SoluÃ§Ã£o 1: Timestamps do Servidor
Separar claramente:
- **Data do servidor**: SEMPRE datetime.utcnow() quando a mensagem Ã© RECEBIDA
- **Data do dispositivo**: Apenas para referÃªncia/debug

### ğŸ”§ SoluÃ§Ã£o 2: Controle de ConexÃµes por IMEI
- Rastrear conexÃµes por IMEI Ãºnico, nÃ£o por socket
- Heartbeats `+ACK:GTHBD` apenas atualizam timestamp, nÃ£o criam nova conexÃ£o
- Thread safety com locks para evitar condiÃ§Ãµes de corrida

### ğŸ”§ SoluÃ§Ã£o 3: Suporte para GTSTT
- Adicionar parser para mensagens `+RESP:GTSTT`
- Interpretar cÃ³digos de estado (41=Sensor Rest, 42=Sensor Motion, etc)
- Salvar mudanÃ§as de estado no banco de dados

---

## ğŸ“ Arquivo 1: `gv50/protocol_parser.py`

### âœ… ADICIONAR suporte para GTSTT:

1. **Na funÃ§Ã£o `__init__()`**, adicionar padrÃ£o GTSTT:
```python
self.message_patterns = {
    # ... padrÃµes existentes ...
    'GTSTT': r'\+(?P<msg_type>RESP|BUFF|ACK):GTSTT,(?P<protocol_version>[^,]*),(?P<imei>[^,]*),(?P<device_name>[^,]*),(?P<state>[^,]*),(?P<gps_accuracy>[^,]*),(?P<speed>[^,]*),(?P<course>[^,]*),(?P<altitude>[^,]*),(?P<longitude>[^,]*),(?P<latitude>[^,]*),(?P<device_timestamp>[^,]*),(?P<mcc>[^,]*),(?P<mnc>[^,]*),(?P<lac>[^,]*),(?P<cell_id>[^,]*),(?P<reserved>[^,]*),(?P<count>[^$]*)\

## ğŸ“ Arquivo 3: `gv50/message_handler.py`

### âœ… CORREÃ‡ÃƒO de timestamps:

1. **Na funÃ§Ã£o `handle_incoming_message()`:**
```python
# âœ… SEMPRE usar timestamp do servidor - NUNCA do dispositivo
server_timestamp = datetime.utcnow()

# Create vehicle data record
vehicle_data = VehicleData(
    imei=imei,
    longitude=parsed_data.get('longitude'),
    latitude=parsed_data.get('latitude'),
    altitude=parsed_data.get('altitude'),
    timestamp=server_timestamp,  # âœ… Data do SERVIDOR
    deviceTimestamp=parsed_data.get('device_timestamp', ''),  # Data do dispositivo apenas para referÃªncia
    systemDate=server_timestamp,  # âœ… Data do SERVIDOR
    mensagem_raw=raw_message
)
```

2. **Na funÃ§Ã£o `save_vehicle_data()`:**
```python
# âœ… SEMPRE usar timestamp do servidor
server_timestamp = datetime.utcnow()

vehicle_record = VehicleData(
    imei=vehicle_data.get('imei', ''),
    longitude=vehicle_data.get('longitude', '0'),
    latitude=vehicle_data.get('latitude', '0'),
    altitude=vehicle_data.get('altitude', '0'),
    timestamp=server_timestamp,  # âœ… Data do SERVIDOR
    deviceTimestamp=vehicle_data.get('device_timestamp', ''),  # Data do dispositivo apenas para referÃªncia
    systemDate=server_timestamp,  # âœ… Data do SERVIDOR
    mensagem_raw=vehicle_data.get('raw_message', '')
)

# Log com timestamps separados para debugar
logger.debug(f"Saved vehicle data for IMEI: {vehicle_data.get('imei')} - Server Time: {server_timestamp.strftime('%Y-%m-%d %H:%M:%S')} - Device Time: {vehicle_data.get('device_timestamp', 'N/A')}")
```

3. **Atualizar TODAS as funÃ§Ãµes que fazem update**, sempre usando:**
```python
# âœ… SEMPRE usar timestamp do servidor
server_timestamp = datetime.utcnow()

vehicle_data = {
    'IMEI': imei,
    # ... outros campos ...
    'tsusermanu': server_timestamp  # âœ… Data do SERVIDOR
}
```

---

## ğŸ“ Arquivo 4: `gv50/models.py`

### âœ… CORREÃ‡ÃƒO dos modelos:

```python
@dataclass
class VehicleData:
    """Vehicle tracking data model - com timestamps separados"""
    imei: str
    longitude: Optional[str] = None
    latitude: Optional[str] = None
    altitude: Optional[str] = None
    
    # âœ… TIMESTAMPS SEPARADOS - IMPORTANTE
    timestamp: Optional[datetime] = None  # SEMPRE timestamp do servidor (UTC)
    systemDate: Optional[datetime] = None  # SEMPRE timestamp do servidor (UTC) 
    deviceTimestamp: str = ""  # Timestamp do dispositivo (apenas para referÃªncia/debug)
    
    mensagem_raw: Optional[str] = None
    
    def __post_init__(self):
        """Garantir que timestamps do servidor sejam sempre atuais"""
        current_time = datetime.utcnow()
        
        # âœ… FORÃ‡AR timestamp do servidor se nÃ£o foi definido
        if self.timestamp is None:
            self.timestamp = current_time
        
        if self.systemDate is None:
            self.systemDate = current_time

@dataclass
class Vehicle:
    # ... campos existentes ...
    
    # âœ… TIMESTAMP DO SERVIDOR - NUNCA do dispositivo
    tsusermanu: Optional[datetime] = None  # Ãšltima atualizaÃ§Ã£o (timestamp do servidor)
    
    def __post_init__(self):
        """Garantir que timestamp seja sempre do servidor"""
        if self.tsusermanu is None:
            self.tsusermanu = datetime.utcnow()  # âœ… SEMPRE timestamp do servidor
```

---

## ğŸ“Š Resultados Esperados ApÃ³s as CorreÃ§Ãµes

### âœ… 1. Timestamps Corretos:
```
GTSTT - IMEI: 865083030086961 | Server Time: 2025-01-26 18:30:45 | Device Time: 20250726143045 | State: 41 (Sensor Rest)
Saved vehicle data for IMEI: 865083030086961 - Server Time: 2025-01-26 18:30:45 - Device Time: 20250726143045
```

### âœ… 2. ConexÃµes Ãšnicas por IMEI:
```
NEW DEVICE CONNECTION: IMEI 865083030086961 from 192.168.1.100
Device 865083030086961 connected from 192.168.1.100 at 2025-01-26 15:30:45

[DEBUG] Heartbeat from IMEI 865083030086961  # Heartbeats subsequentes
[DEBUG] Activity from known device: IMEI 865083030086961
```

### âœ… 3. GTSTT Processado:
```
ğŸ“± Device State Change: IMEI 865083030086961 -> Sensor Rest (No Ignition Signal)
GTSTT: IMEI 865083030086961 - State: 41 (Sensor Rest (No Ignition Signal))
```

### âœ… 4. Estrutura no Banco:
```json
{
  "imei": "865083030086961",
  "timestamp": "2025-01-26T18:30:45.123Z",     // âœ… SERVIDOR
  "systemDate": "2025-01-26T18:30:45.123Z",   // âœ… SERVIDOR  
  "deviceTimestamp": "20250726143045",         // â“ DISPOSITIVO (referÃªncia)
  "device_state": "41",                        // âœ… NOVO: Estado do dispositivo
  "state_description": "Sensor Rest (No Ignition Signal)", // âœ… NOVO
  "longitude": "-46.778597",
  "latitude": "-23.5"
}
```

---

## ğŸ¯ Mensagem de Teste

Use esta mensagem para validar todas as correÃ§Ãµes:
```
+RESP:GTSTT,090302,865083030086961,,41,0,0.0,76,744.6,-46.778597,-23.5
```

E esta para heartbeat:
```
+ACK:GTHBD,090302,865083030086961,,20250724055411,0497$
```

## âœ… ValidaÃ§Ã£o Final

ApÃ³s as alteraÃ§Ãµes, vocÃª deve ver:
- âœ… **Timestamps** do servidor sempre atuais (UTC)
- âœ… **Heartbeats** nÃ£o duplicam conexÃµes  
- âœ… **GTSTT** sendo processado e salvo
- âœ… **Logs** separando timestamps do servidor vs dispositivo
- âœ… **ConexÃµes Ãºnicas** por IMEI (nÃ£o por socket)
- âœ… **Estados de dispositivo** interpretados corretamente

## ğŸš€ InstruÃ§Ãµes para Replit

1. **FaÃ§a backup** de todos os arquivos mencionados
2. **Aplique as alteraÃ§Ãµes** nos 4 arquivos na ordem apresentada
3. **Teste** com a mensagem GTSTT fornecida
4. **Verifique** que heartbeats nÃ£o criam novas conexÃµes
5. **Confirme** logs com timestamps separados
6. **Valide** no banco os dados do GTSTT com timestamps corretosğŸ“Š Resultado Esperado

### Logs corrigidos:
```
GTSTT - IMEI: 865083030086961 | Server Time: 2025-01-26 18:30:45 | Device Time: 20250726143045 | State: 41 (Sensor Rest)
ğŸ“± Device State Change: IMEI 865083030086961 -> Sensor Rest [Server: 2025-01-26 18:30:45]

Saved vehicle data for IMEI: 865083030086961 - Server Time: 2025-01-26 18:30:45 - Device Time: 20250726143045
```

### Estrutura no banco:
```json
{
  "imei": "865083030086961",
  "timestamp": "2025-01-26T18:30:45.123Z",     // âœ… SERVIDOR
  "systemDate": "2025-01-26T18:30:45.123Z",   // âœ… SERVIDOR  
  "deviceTimestamp": "20250726143045",         // â“ DISPOSITIVO (referÃªncia)
  "longitude": "-46.778597",
  "latitude": "-23.5"
}
```

---

## ğŸ¯ InstruÃ§Ãµes para o Replit

1. **FaÃ§a backup** dos arquivos atuais
2. **Aplique as alteraÃ§Ãµes** nos 3 arquivos mencionados
3. **Teste** com uma mensagem do dispositivo
4. **Verifique** se os logs mostram timestamps separados
5. **Confirme** no banco que `timestamp` e `systemDate` sÃ£o do servidor
6. **Valide** que `deviceTimestamp` Ã© apenas string para referÃªncia

## âœ… ValidaÃ§Ã£o Final

ApÃ³s as alteraÃ§Ãµes, vocÃª deve ver:
- âœ… Timestamps do servidor sempre atuais (UTC)
- âœ… Timestamps do dispositivo apenas como referÃªncia
- âœ… Logs separando claramente as duas datas
- âœ… ConsistÃªncia temporal nos dados do banco
- âœ… Auditoria correta de quando o servidor recebeu vs quando o dispositivo enviou
}
```

2. **Na funÃ§Ã£o `parse_message()`**, adicionar caso GTSTT:
```python
elif message_type == 'GTSTT':
    return self._parse_gtstt(message)  # âœ… NOVO
```

3. **ADICIONAR nova funÃ§Ã£o `_parse_gtstt()`**:
```python
def _parse_gtstt(self, message: str) -> Dict[str, str]:
    """Parse GTSTT message (Status State Change Report)"""
    try:
        # Remove prefix and suffix
        if not message.startswith('+') or not message.endswith('

## ğŸ“ Arquivo 1: `gv50/message_handler.py`

### AlteraÃ§Ãµes necessÃ¡rias:

1. **Na funÃ§Ã£o `handle_incoming_message()`:**
```python
# âœ… SEMPRE usar timestamp do servidor - NUNCA do dispositivo
server_timestamp = datetime.utcnow()

# Create vehicle data record
vehicle_data = VehicleData(
    imei=imei,
    longitude=parsed_data.get('longitude'),
    latitude=parsed_data.get('latitude'),
    altitude=parsed_data.get('altitude'),
    timestamp=server_timestamp,  # âœ… Data do SERVIDOR
    deviceTimestamp=parsed_data.get('device_timestamp', ''),  # Data do dispositivo apenas para referÃªncia
    systemDate=server_timestamp,  # âœ… Data do SERVIDOR
    mensagem_raw=raw_message
)
```

2. **Na funÃ§Ã£o `_update_vehicle_info()`:**
```python
# âœ… SEMPRE usar timestamp do servidor
server_timestamp = datetime.utcnow()

vehicle_data = {
    'IMEI': imei,
    'tsusermanu': server_timestamp  # âœ… Data do SERVIDOR
}
```

3. **Na funÃ§Ã£o `save_vehicle_data()`:**
```python
# âœ… SEMPRE usar timestamp do servidor
server_timestamp = datetime.utcnow()

vehicle_record = VehicleData(
    imei=vehicle_data.get('imei', ''),
    longitude=vehicle_data.get('longitude', '0'),
    latitude=vehicle_data.get('latitude', '0'),
    altitude=vehicle_data.get('altitude', '0'),
    timestamp=server_timestamp,  # âœ… Data do SERVIDOR
    deviceTimestamp=vehicle_data.get('device_timestamp', ''),  # Data do dispositivo apenas para referÃªncia
    systemDate=server_timestamp,  # âœ… Data do SERVIDOR
    mensagem_raw=vehicle_data.get('raw_message', '')
)

# Log com timestamps separados para debugar
logger.debug(f"Saved vehicle data for IMEI: {vehicle_data.get('imei')} - Server Time: {server_timestamp.strftime('%Y-%m-%d %H:%M:%S')} - Device Time: {vehicle_data.get('device_timestamp', 'N/A')}")
```

4. **Atualizar todas as funÃ§Ãµes que fazem update:**
- `update_vehicle_ignition()`
- `update_vehicle_blocking()`
- `set_blocking_command()`
- `set_ip_change_command()`

Em todas, adicionar:
```python
# âœ… SEMPRE usar timestamp do servidor
server_timestamp = datetime.utcnow()

vehicle_data = {
    'IMEI': imei,
    # ... outros campos ...
    'tsusermanu': server_timestamp  # âœ… Data do SERVIDOR
}
```

---

## ğŸ“ Arquivo 2: `gv50/models.py`

### AlteraÃ§Ãµes no modelo `VehicleData`:

```python
@dataclass
class VehicleData:
    """Vehicle tracking data model - apenas dados de localizaÃ§Ã£o com timestamps separados"""
    imei: str
    longitude: Optional[str] = None
    latitude: Optional[str] = None
    altitude: Optional[str] = None
    
    # âœ… TIMESTAMPS SEPARADOS - IMPORTANTE
    timestamp: Optional[datetime] = None  # SEMPRE timestamp do servidor (UTC)
    systemDate: Optional[datetime] = None  # SEMPRE timestamp do servidor (UTC) 
    deviceTimestamp: str = ""  # Timestamp do dispositivo (apenas para referÃªncia/debug)
    
    mensagem_raw: Optional[str] = None
    
    def __post_init__(self):
        """Garantir que timestamps do servidor sejam sempre atuais"""
        current_time = datetime.utcnow()
        
        # âœ… FORÃ‡AR timestamp do servidor se nÃ£o foi definido
        if self.timestamp is None:
            self.timestamp = current_time
        
        if self.systemDate is None:
            self.systemDate = current_time
```

### AlteraÃ§Ãµes no modelo `Vehicle`:

```python
@dataclass
class Vehicle:
    # ... campos existentes ...
    
    # âœ… TIMESTAMP DO SERVIDOR - NUNCA do dispositivo
    tsusermanu: Optional[datetime] = None  # Ãšltima atualizaÃ§Ã£o (timestamp do servidor)
    
    def __post_init__(self):
        """Garantir que timestamp seja sempre do servidor"""
        if self.tsusermanu is None:
            self.tsusermanu = datetime.utcnow()  # âœ… SEMPRE timestamp do servidor
```

---

## ğŸ“ Arquivo 3: `gv50/tcp_server_csharp_style.py`

### Na funÃ§Ã£o `process_resp_message()`:

```python
def process_resp_message(self, command_parts: List[str], client_socket: socket.socket, client_ip: str):
    """Process +RESP messages like C# - TIMESTAMP DO SERVIDOR SEMPRE"""
    try:
        if len(command_parts) > 0:
            command_type = command_parts[0]
            
            # âœ… SEMPRE usar timestamp do servidor - NUNCA do dispositivo
            server_timestamp = time.strftime('%Y-%m-%d %H:%M:%S')
            
            if command_type == "GTFRI":
                if len(command_parts) > 13:
                    vehicle_data = {
                        'imei': command_parts[2],
                        'speed': command_parts[8],
                        'altitude': command_parts[10],
                        'longitude': command_parts[11],
                        'latitude': command_parts[12],
                        'device_timestamp': command_parts[13],  # Apenas para referÃªncia
                        'server_timestamp': server_timestamp,  # âœ… Data do SERVIDOR
                        'raw_message': '+RESP:' + ','.join(command_parts)
                    }
                    
                    # Log separando timestamps
                    logger.debug(f"GTFRI - IMEI: {vehicle_data['imei']} | Server Time: {server_timestamp} | Device Time: {command_parts[13]}")
```

### Aplicar a mesma lÃ³gica para:
- `GTIGN` e `GTIGF`
- `GTSTT` 
- `process_buff_message()`

Sempre usando:
- `server_timestamp` para salvar no banco
- `device_timestamp` apenas para logs/referÃªncia

---

## ğŸ“Š Resultado Esperado

### Logs corrigidos:
```
GTSTT - IMEI: 865083030086961 | Server Time: 2025-01-26 18:30:45 | Device Time: 20250726143045 | State: 41 (Sensor Rest)
ğŸ“± Device State Change: IMEI 865083030086961 -> Sensor Rest [Server: 2025-01-26 18:30:45]

Saved vehicle data for IMEI: 865083030086961 - Server Time: 2025-01-26 18:30:45 - Device Time: 20250726143045
```

### Estrutura no banco:
```json
{
  "imei": "865083030086961",
  "timestamp": "2025-01-26T18:30:45.123Z",     // âœ… SERVIDOR
  "systemDate": "2025-01-26T18:30:45.123Z",   // âœ… SERVIDOR  
  "deviceTimestamp": "20250726143045",         // â“ DISPOSITIVO (referÃªncia)
  "longitude": "-46.778597",
  "latitude": "-23.5"
}
```

---

## ğŸ¯ InstruÃ§Ãµes para o Replit

1. **FaÃ§a backup** dos arquivos atuais
2. **Aplique as alteraÃ§Ãµes** nos 3 arquivos mencionados
3. **Teste** com uma mensagem do dispositivo
4. **Verifique** se os logs mostram timestamps separados
5. **Confirme** no banco que `timestamp` e `systemDate` sÃ£o do servidor
6. **Valide** que `deviceTimestamp` Ã© apenas string para referÃªncia

## âœ… ValidaÃ§Ã£o Final

ApÃ³s as alteraÃ§Ãµes, vocÃª deve ver:
- âœ… Timestamps do servidor sempre atuais (UTC)
- âœ… Timestamps do dispositivo apenas como referÃªncia
- âœ… Logs separando claramente as duas datas
- âœ… ConsistÃªncia temporal nos dados do banco
- âœ… Auditoria correta de quando o servidor recebeu vs quando o dispositivo enviou):
            return {'error': 'Invalid GTSTT message format'}
        
        # Split by ':' first to get msg_type and data part
        msg_parts = message[1:-1].split(':', 1)  # Remove + and $
        if len(msg_parts) != 2:
            return {'error': 'Invalid GTSTT message structure'}
        
        msg_type = msg_parts[0]  # RESP, BUFF, ACK
        data_part = msg_parts[1]
        
        # Split data part by comma
        fields = data_part.split(',')
        
        if len(fields) < 11:  # Minimum required fields for GTSTT
            return {'error': f'Insufficient fields in GTSTT: {len(fields)}'}
        
        # Map fields according to GTSTT protocol
        data = {
            'msg_type': msg_type,
            'report_type': 'GTSTT',
            'protocol_version': fields[1] if len(fields) > 1 else '',
            'imei': fields[2] if len(fields) > 2 else '',
            'device_name': fields[3] if len(fields) > 3 else '',
            'state': fields[4] if len(fields) > 4 else '',  # Estado do dispositivo (41, 42, etc)
            'gps_accuracy': fields[5] if len(fields) > 5 else '0',
            'speed': fields[6] if len(fields) > 6 else '0',
            'course': fields[7] if len(fields) > 7 else '0',
            'altitude': fields[8] if len(fields) > 8 else '0',
            'longitude': fields[9] if len(fields) > 9 else '0',
            'latitude': fields[10] if len(fields) > 10 else '0',
            'device_timestamp': fields[11] if len(fields) > 11 else '',
            'count': fields[17] if len(fields) > 17 else '0'
        }
        
        # Interpretar o estado do dispositivo
        device_state = data.get('state', '')
        data['device_status_description'] = self._interpret_device_state(device_state)
        
        # Convert numeric fields
        self._convert_numeric_fields(data)
        
        logger.info(f"GTSTT: IMEI {data.get('imei')} - State: {device_state} ({data['device_status_description']})")
        return data
        
    except Exception as e:
        logger.error(f"Error parsing GTSTT: {e}")
        return {'error': f'GTSTT parse error: {str(e)}'}

def _interpret_device_state(self, state: str) -> str:
    """Interpret device state code"""
    state_map = {
        '11': 'Ignition OFF + Rest',
        '12': 'Ignition OFF + Motion', 
        '16': 'Towed',
        '1A': 'Fake Tow',
        '21': 'Ignition ON + Rest',
        '22': 'Ignition ON + Motion',
        '41': 'Sensor Rest (No Ignition Signal)',  # âœ… Estado da sua mensagem
        '42': 'Sensor Motion (No Ignition Signal)'
    }
    return state_map.get(state, f'Unknown State ({state})')
```

4. **Na funÃ§Ã£o `_detect_message_type()`**, adicionar GTSTT:
```python
def _detect_message_type(self, message: str) -> Optional[str]:
    """Detect message type from the message content"""
    # Adicionado GTSTT na detecÃ§Ã£o
    message_types = ['GTFRI', 'GTIGN', 'GTIGF', 'GTOUT', 'GTSTT']
    
    for msg_type in message_types:
        if f':{msg_type},' in message:
            return msg_type
    return None
```

---

## ğŸ“ Arquivo 2: `gv50/tcp_server_csharp_style.py`

### âœ… CORREÃ‡ÃƒO COMPLETA para controle de conexÃµes e GTSTT:

1. **ADICIONAR no `__init__()`**:
```python
def __init__(self):
    self.server_socket = None
    self.running = False
    self.client_sockets: List[socket.socket] = []
    self.active_connections: Dict[str, Dict] = {}  # âœ… Track connections by IMEI
    self.connection_lock = threading.Lock()  # âœ… Thread safety
    self.listener_thread = None
    self.bytes_buffer = bytearray(999999999)
```

2. **ADICIONAR funÃ§Ãµes de controle de conexÃ£o**:
```python
def register_device_connection(self, imei: str, client_socket: socket.socket, client_ip: str):
    """Register a device connection - only count each IMEI once"""
    with self.connection_lock:
        if imei not in self.active_connections:
            self.active_connections[imei] = {
                'socket': client_socket,
                'ip': client_ip,
                'connected_at': time.time(),
                'last_heartbeat': time.time(),
                'message_count': 0
            }
            logger.info(f"NEW DEVICE CONNECTION: IMEI {imei} from {client_ip}")
            print(f"Device {imei} connected from {client_ip} at {time.strftime('%Y-%m-%d %H:%M:%S')}")
        else:
            # Device already connected - update last activity
            self.active_connections[imei]['last_heartbeat'] = time.time()
            self.active_connections[imei]['message_count'] += 1
            logger.debug(f"Activity from known device: IMEI {imei}")

def unregister_device_connection(self, imei: str):
    """Unregister a device connection"""
    with self.connection_lock:
        if imei in self.active_connections:
            connection_info = self.active_connections[imei]
            duration = time.time() - connection_info['connected_at']
            logger.info(f"DEVICE DISCONNECTED: IMEI {imei}, Duration: {duration:.0f}s, Messages: {connection_info['message_count']}")
            del self.active_connections[imei]

def extract_imei_from_message(self, message: str) -> Optional[str]:
    """Extract IMEI from any message format"""
    try:
        # Split by comma and look for IMEI pattern (15 digits)
        parts = message.split(',')
        for part in parts:
            part = part.strip()
            if len(part) == 15 and part.isdigit():
                return part
        return None
    except:
        return None

def get_connection_count(self) -> int:
    """Get current UNIQUE device connection count (by IMEI)"""
    with self.connection_lock:
        return len(self.active_connections)

def get_active_devices(self) -> List[str]:
    """Get list of active device IMEIs"""
    with self.connection_lock:
        return list(self.active_connections.keys())
```

3. **MODIFICAR `read_callback()`** para detectar heartbeats:
```python
def read_callback(self, client_socket: socket.socket, data: bytes, client_ip: str) -> Optional[str]:
    """Process received data - com controle de heartbeat"""
    try:
        # ... cÃ³digo de decodificaÃ§Ã£o existente ...
        
        # âœ… Check if this is a heartbeat message
        if "+ACK:GTHBD" in message:
            # Extract IMEI from heartbeat
            imei = self.extract_imei_from_message(message)
            if imei:
                # Update last heartbeat time but don't log as new connection
                with self.connection_lock:
                    if imei in self.active_connections:
                        self.active_connections[imei]['last_heartbeat'] = time.time()
                        logger.debug(f"Heartbeat from IMEI {imei}")
                    else:
                        # First heartbeat from this device
                        self.register_device_connection(imei, client_socket, client_ip)
            return imei
        
        # Log the message like C# (only non-heartbeat messages)
        print(f"\nMessage received {time.strftime('%Y-%m-%d %H:%M:%S')}")
        print(message)
        
        # ... resto do cÃ³digo existente ...
    except Exception as e:
        logger.error(f"Error in read_callback: {e}")
        return None
```

4. **MODIFICAR `process_resp_message()`** para incluir GTSTT e timestamps corretos:
```python
def process_resp_message(self, command_parts: List[str], client_socket: socket.socket, client_ip: str):
    """Process +RESP messages - COM GTSTT E TIMESTAMPS CORRETOS"""
    try:
        if len(command_parts) > 0:
            command_type = command_parts[0]
            
            # âœ… SEMPRE usar timestamp do servidor - NUNCA do dispositivo
            server_timestamp = time.strftime('%Y-%m-%d %H:%M:%S')
            
            # ... cÃ³digo existente para GTFRI, GTIGN, GTIGF ...
            
            # âœ… NOVO: Suporte para GTSTT (Status State Change)
            elif command_type == "GTSTT":
                if len(command_parts) > 10:
                    # Map fields for GTSTT
                    vehicle_data = {
                        'imei': command_parts[2],
                        'device_state': command_parts[4],  # Estado do dispositivo (41, 42, etc)
                        'gps_accuracy': command_parts[5],
                        'speed': command_parts[6],
                        'course': command_parts[7],
                        'altitude': command_parts[8],
                        'longitude': command_parts[9],
                        'latitude': command_parts[10],
                        'device_timestamp': command_parts[11] if len(command_parts) > 11 else '',
                        'server_timestamp': server_timestamp,  # âœ… Data do SERVIDOR
                        'raw_message': '+RESP:' + ','.join(command_parts)
                    }
                    
                    # Interpretar o estado do dispositivo
                    state_description = self.interpret_device_state(vehicle_data['device_state'])
                    vehicle_data['state_description'] = state_description
                    
                    # Log detalhado para GTSTT
                    logger.info(f"GTSTT: IMEI {vehicle_data['imei']} - State: {vehicle_data['device_state']} ({state_description})")
                    print(f"ğŸ“± Device State Change: IMEI {vehicle_data['imei']} -> {state_description}")
                    
                    # Save to database
                    message_handler.save_vehicle_data(vehicle_data)
                    
                    # Send command if needed
                    self.send_command(client_socket, vehicle_data['imei'])
                    
    except Exception as e:
        logger.error(f"Error processing RESP message: {e}")

def interpret_device_state(self, state: str) -> str:
    """Interpret device state code for GTSTT"""
    state_map = {
        '11': 'Ignition OFF + Rest',
        '12': 'Ignition OFF + Motion', 
        '16': 'Towed',
        '1A': 'Fake Tow',
        '21': 'Ignition ON + Rest',
        '22': 'Ignition ON + Motion',
        '41': 'Sensor Rest (No Ignition Signal)',  # âœ… Sua mensagem
        '42': 'Sensor Motion (No Ignition Signal)'
    }
    return state_map.get(state, f'Unknown State ({state})')
```

---

## ğŸ“ Arquivo 1: `gv50/message_handler.py`

### AlteraÃ§Ãµes necessÃ¡rias:

1. **Na funÃ§Ã£o `handle_incoming_message()`:**
```python
# âœ… SEMPRE usar timestamp do servidor - NUNCA do dispositivo
server_timestamp = datetime.utcnow()

# Create vehicle data record
vehicle_data = VehicleData(
    imei=imei,
    longitude=parsed_data.get('longitude'),
    latitude=parsed_data.get('latitude'),
    altitude=parsed_data.get('altitude'),
    timestamp=server_timestamp,  # âœ… Data do SERVIDOR
    deviceTimestamp=parsed_data.get('device_timestamp', ''),  # Data do dispositivo apenas para referÃªncia
    systemDate=server_timestamp,  # âœ… Data do SERVIDOR
    mensagem_raw=raw_message
)
```

2. **Na funÃ§Ã£o `_update_vehicle_info()`:**
```python
# âœ… SEMPRE usar timestamp do servidor
server_timestamp = datetime.utcnow()

vehicle_data = {
    'IMEI': imei,
    'tsusermanu': server_timestamp  # âœ… Data do SERVIDOR
}
```

3. **Na funÃ§Ã£o `save_vehicle_data()`:**
```python
# âœ… SEMPRE usar timestamp do servidor
server_timestamp = datetime.utcnow()

vehicle_record = VehicleData(
    imei=vehicle_data.get('imei', ''),
    longitude=vehicle_data.get('longitude', '0'),
    latitude=vehicle_data.get('latitude', '0'),
    altitude=vehicle_data.get('altitude', '0'),
    timestamp=server_timestamp,  # âœ… Data do SERVIDOR
    deviceTimestamp=vehicle_data.get('device_timestamp', ''),  # Data do dispositivo apenas para referÃªncia
    systemDate=server_timestamp,  # âœ… Data do SERVIDOR
    mensagem_raw=vehicle_data.get('raw_message', '')
)

# Log com timestamps separados para debugar
logger.debug(f"Saved vehicle data for IMEI: {vehicle_data.get('imei')} - Server Time: {server_timestamp.strftime('%Y-%m-%d %H:%M:%S')} - Device Time: {vehicle_data.get('device_timestamp', 'N/A')}")
```

4. **Atualizar todas as funÃ§Ãµes que fazem update:**
- `update_vehicle_ignition()`
- `update_vehicle_blocking()`
- `set_blocking_command()`
- `set_ip_change_command()`

Em todas, adicionar:
```python
# âœ… SEMPRE usar timestamp do servidor
server_timestamp = datetime.utcnow()

vehicle_data = {
    'IMEI': imei,
    # ... outros campos ...
    'tsusermanu': server_timestamp  # âœ… Data do SERVIDOR
}
```

---

## ğŸ“ Arquivo 2: `gv50/models.py`

### AlteraÃ§Ãµes no modelo `VehicleData`:

```python
@dataclass
class VehicleData:
    """Vehicle tracking data model - apenas dados de localizaÃ§Ã£o com timestamps separados"""
    imei: str
    longitude: Optional[str] = None
    latitude: Optional[str] = None
    altitude: Optional[str] = None
    
    # âœ… TIMESTAMPS SEPARADOS - IMPORTANTE
    timestamp: Optional[datetime] = None  # SEMPRE timestamp do servidor (UTC)
    systemDate: Optional[datetime] = None  # SEMPRE timestamp do servidor (UTC) 
    deviceTimestamp: str = ""  # Timestamp do dispositivo (apenas para referÃªncia/debug)
    
    mensagem_raw: Optional[str] = None
    
    def __post_init__(self):
        """Garantir que timestamps do servidor sejam sempre atuais"""
        current_time = datetime.utcnow()
        
        # âœ… FORÃ‡AR timestamp do servidor se nÃ£o foi definido
        if self.timestamp is None:
            self.timestamp = current_time
        
        if self.systemDate is None:
            self.systemDate = current_time
```

### AlteraÃ§Ãµes no modelo `Vehicle`:

```python
@dataclass
class Vehicle:
    # ... campos existentes ...
    
    # âœ… TIMESTAMP DO SERVIDOR - NUNCA do dispositivo
    tsusermanu: Optional[datetime] = None  # Ãšltima atualizaÃ§Ã£o (timestamp do servidor)
    
    def __post_init__(self):
        """Garantir que timestamp seja sempre do servidor"""
        if self.tsusermanu is None:
            self.tsusermanu = datetime.utcnow()  # âœ… SEMPRE timestamp do servidor
```

---

## ğŸ“ Arquivo 3: `gv50/tcp_server_csharp_style.py`

### Na funÃ§Ã£o `process_resp_message()`:

```python
def process_resp_message(self, command_parts: List[str], client_socket: socket.socket, client_ip: str):
    """Process +RESP messages like C# - TIMESTAMP DO SERVIDOR SEMPRE"""
    try:
        if len(command_parts) > 0:
            command_type = command_parts[0]
            
            # âœ… SEMPRE usar timestamp do servidor - NUNCA do dispositivo
            server_timestamp = time.strftime('%Y-%m-%d %H:%M:%S')
            
            if command_type == "GTFRI":
                if len(command_parts) > 13:
                    vehicle_data = {
                        'imei': command_parts[2],
                        'speed': command_parts[8],
                        'altitude': command_parts[10],
                        'longitude': command_parts[11],
                        'latitude': command_parts[12],
                        'device_timestamp': command_parts[13],  # Apenas para referÃªncia
                        'server_timestamp': server_timestamp,  # âœ… Data do SERVIDOR
                        'raw_message': '+RESP:' + ','.join(command_parts)
                    }
                    
                    # Log separando timestamps
                    logger.debug(f"GTFRI - IMEI: {vehicle_data['imei']} | Server Time: {server_timestamp} | Device Time: {command_parts[13]}")
```

### Aplicar a mesma lÃ³gica para:
- `GTIGN` e `GTIGF`
- `GTSTT` 
- `process_buff_message()`

Sempre usando:
- `server_timestamp` para salvar no banco
- `device_timestamp` apenas para logs/referÃªncia

---

## ğŸ“Š Resultado Esperado

### Logs corrigidos:
```
GTSTT - IMEI: 865083030086961 | Server Time: 2025-01-26 18:30:45 | Device Time: 20250726143045 | State: 41 (Sensor Rest)
ğŸ“± Device State Change: IMEI 865083030086961 -> Sensor Rest [Server: 2025-01-26 18:30:45]

Saved vehicle data for IMEI: 865083030086961 - Server Time: 2025-01-26 18:30:45 - Device Time: 20250726143045
```

### Estrutura no banco:
```json
{
  "imei": "865083030086961",
  "timestamp": "2025-01-26T18:30:45.123Z",     // âœ… SERVIDOR
  "systemDate": "2025-01-26T18:30:45.123Z",   // âœ… SERVIDOR  
  "deviceTimestamp": "20250726143045",         // â“ DISPOSITIVO (referÃªncia)
  "longitude": "-46.778597",
  "latitude": "-23.5"
}
```

---

## ğŸ¯ InstruÃ§Ãµes para o Replit

1. **FaÃ§a backup** dos arquivos atuais
2. **Aplique as alteraÃ§Ãµes** nos 3 arquivos mencionados
3. **Teste** com uma mensagem do dispositivo
4. **Verifique** se os logs mostram timestamps separados
5. **Confirme** no banco que `timestamp` e `systemDate` sÃ£o do servidor
6. **Valide** que `deviceTimestamp` Ã© apenas string para referÃªncia

## âœ… ValidaÃ§Ã£o Final

ApÃ³s as alteraÃ§Ãµes, vocÃª deve ver:
- âœ… Timestamps do servidor sempre atuais (UTC)
- âœ… Timestamps do dispositivo apenas como referÃªncia
- âœ… Logs separando claramente as duas datas
- âœ… ConsistÃªncia temporal nos dados do banco
- âœ… Auditoria correta de quando o servidor recebeu vs quando o dispositivo enviou